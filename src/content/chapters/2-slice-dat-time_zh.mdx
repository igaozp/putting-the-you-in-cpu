---
chapter: 2
title: 切片时间
shortname: 多任务
slug: slice-dat-time
updatedAt: 2023-08-02T18:14:02.296Z
---

假设你正在构建一个操作系统，并且希望用户能够同时运行多个程序。但是你没有花哨的多核处理器，所以你的 CPU 一次只能运行一条指令！

幸运的是，你是一位非常聪明的操作系统开发人员。你发现可以通过让进程轮流使用 CPU 来伪造并行性。如果你循环遍历进程并从每个进程运行几条指令，它们都可以响应，而不会让任何单个进程独占 CPU。

但是如何从程序代码中夺回控制权以切换进程？经过一番研究，你发现大多数计算机都配备了计时器芯片。你可以对计时器芯片进行编程，以便在经过一定时间后触发切换到操作系统中断处理程序。

## 硬件中断

之前，我们讨论了软件中断如何用于将控制从用户空间程序移交给操作系统。这些被称为"软件"中断，因为它们是由程序自愿触发的——处理器在正常的取指-执行循环中执行的机器码告诉它将控制切换到内核。

<img src='/images/keyboard-hardware-interrupt.png' loading='eager' style='max-width: 500px; margin: 0 auto;' alt='一幅插图，说明硬件中断如何打断正常执行。顶部：一个键盘的图画，有一个突出显示的键，右侧有一个闪电指向 CPU。底部：一些标记为"程序代码"的二进制，一个类似的闪电，以及一些标记为"内核代码"的二进制。闪电标记为"中断触发上下文切换"。' width='935' height='503' />

操作系统调度器使用*计时器芯片*（如 [PIT](https://en.wikipedia.org/wiki/Programmable_interval_timer)）来触发硬件中断以实现多任务：

1. 在跳转到程序代码之前，操作系统将计时器芯片设置为在一段时间后触发中断。
2. 操作系统切换到用户模式并跳转到程序的下一条指令。
3. 当计时器到期时，它触发硬件中断以切换到内核模式并跳转到操作系统代码。
4. 操作系统现在可以保存程序离开的位置，加载不同的程序，并重复该过程。

这称为*抢占式多任务*；进程的中断称为[*抢占*](https://en.wikipedia.org/wiki/Preemption_(computing))。如果你，比如说，在浏览器上阅读这篇文章并在同一台机器上听音乐，你自己的计算机可能每秒都在遵循这个确切的循环数千次。

## 时间片计算

*时间片*是操作系统调度器允许进程在抢占它之前运行的持续时间。选择时间片的最简单方法是给每个进程相同的时间片，可能在 10&nbsp;ms 范围内，并按顺序循环任务。这称为*固定时间片轮询*调度。

> **补充说明：有趣的术语事实！**
>
> 你知道时间片通常被称为"量子"吗？现在你知道了，你可以给你所有的技术朋友留下深刻印象。我认为我应该因为没有在这篇文章的每隔一句话中说量子而受到大量赞扬。
>
> 说到时间片术语，Linux 内核开发人员使用 [jiffy](https://github.com/torvalds/linux/blob/22b8cc3e78f5448b4c5df00303817a9137cd663f/include/linux/jiffies.h) 时间单位来计算固定频率计时器滴答。除其他事项外，jiffy 用于测量时间片的长度。Linux 的 jiffy 频率通常是 1000 Hz，但可以在编译内核时配置。

对固定时间片调度的轻微改进是选择*目标延迟*——进程响应的理想最长时间。目标延迟是进程在被抢占后恢复执行所需的时间，假设进程数量合理。*这很难可视化！别担心，很快就会有一个图表。*

时间片通过将目标延迟除以任务总数来计算；这比固定时间片调度更好，因为它消除了进程较少时的浪费任务切换。目标延迟为 15&nbsp;ms，有 10 个进程，每个进程将获得 15/10 或 1.5&nbsp;ms 的运行时间。只有 3 个进程时，每个进程获得更长的 5&nbsp;ms 时间片，同时仍然达到目标延迟。

进程切换在计算上是昂贵的，因为它需要保存当前程序的整个状态并恢复不同的状态。超过某个点，太小的时间片可能会导致性能问题，进程切换过于频繁。通常给时间片持续时间一个下限（*最小粒度*）。这确实意味着当有足够多的进程使最小粒度生效时，目标延迟会被超过。

在撰写本文时，Linux 的调度器使用 6&nbsp;ms 的目标延迟和 0.75&nbsp;ms 的最小粒度。

<img src='/images/linux-scheduler-target-latency.png' loading='lazy' style='max-width: 500px; margin: 0 auto;' alt='一个标题为"朴素动态时间片轮询调度"的图表。它描绘了 3 个不同进程在重复循环中获得执行时间的时间序列。每个进程的执行块之间是一个标记为"内核调度器"的短得多的块。每个程序执行块的长度标记为"时间片（2ms）"。从进程 1 开始执行到下一次进程 1 开始执行的距离，包括进程 2 和 3 的执行时间，标记为"目标延迟（6ms）"。' width='935' height='433' />

使用这种基本时间片计算的轮询调度接近现在大多数计算机的做法。它仍然有点天真；大多数操作系统倾向于拥有更复杂的调度器，它们考虑进程优先级和截止日期。自 2007 年以来，Linux 使用了一个名为[完全公平调度器](https://docs.kernel.org/scheduler/sched-design-CFS.html)的调度器。CFS 做了一堆非常花哨的计算机科学事情来优先处理任务并分配 CPU 时间。

每次操作系统抢占一个进程时，它需要加载新程序保存的执行上下文，包括其内存环境。这是通过告诉 CPU 使用不同的*页表*来完成的，页表是从"虚拟"地址到物理地址的映射。这也是防止程序访问彼此内存的系统；我们将在本文的第 [5](/the-translator-in-your-computer) 章和第 [6](/lets-talk-about-forks-and-cows) 章深入探讨这个兔子洞。

## 注释 #1：内核可抢占性

到目前为止，我们只讨论了用户空间进程的抢占和调度。如果内核代码在处理系统调用或执行驱动程序代码时花费太长时间，可能会使程序感觉迟钝。

现代内核，包括 Linux，都是[可抢占内核](https://en.wikipedia.org/wiki/Kernel_preemption)。这意味着它们以一种允许内核代码本身像用户空间进程一样被中断和调度的方式进行编程。

除非你正在编写内核或其他什么东西，否则这不是很重要，但基本上我读过的每篇文章都提到了这一点，所以我想我也应该提一下！额外的知识很少是坏事。

## 注释 #2：历史课

古老的操作系统，包括经典的 Mac OS 和 NT 之前很久的 Windows 版本，使用抢占式多任务的前身。操作系统不是决定何时抢占程序，而是程序本身会选择让给操作系统。它们会触发软件中断说，"嘿，你可以让另一个程序现在运行了。"这些显式的让步是操作系统重新获得控制并切换到下一个计划进程的唯一方式。

这称为[*协作式多任务*](https://en.wikipedia.org/wiki/Cooperative_multitasking)。它有几个主要缺陷：恶意或设计不良的程序很容易冻结整个操作系统，并且几乎不可能确保实时/时间敏感任务的时间一致性。由于这些原因，科技界很久以前就切换到抢占式多任务，再也没有回头。
