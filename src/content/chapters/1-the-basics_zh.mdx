---
chapter: 1
title: "基础知识"
shortname: 基础知识
slug: the-basics
updatedAt: 2023-07-19T18:57:54.630Z
---

在撰写这篇文章的过程中，一次又一次让我感到惊讶的是计算机是多么*简单*。我仍然很难不让自己陷入困境，期待比实际存在更多的复杂性或抽象！如果在继续之前有一件事你应该铭记在心，那就是看起来简单的一切实际上就是那么简单。这种简单性非常美丽，有时也非常非常诅咒。

让我们从计算机在其核心如何工作的基础知识开始。

## 计算机的架构

计算机的*中央处理器*（CPU）负责所有计算。它是大老板。是魔法核心。从你启动计算机的那一刻起，它就开始运转，一条接一条地执行指令。

第一个大规模生产的 CPU 是 [Intel 4004](http://www.intel4004.com/)，由一位名叫 Federico Faggin 的意大利物理学家和工程师在 60 年代末设计。它是一个 4 位架构，而不是我们今天使用的 [64 位](https://en.wikipedia.org/wiki/64-bit_computing)系统，它远没有现代处理器复杂，但它的许多简单性确实保留了下来。

CPU 执行的"指令"只是二进制数据：一两个字节表示正在运行的指令（操作码），后面跟着运行指令所需的任何数据。我们所说的*机器码*只不过是一系列这样的二进制指令。[汇编语言](https://en.wikipedia.org/wiki/Assembly_language)是一种用于读写机器码的有用语法，对人类来说比原始位更容易阅读和编写；它总是被编译成你的 CPU 知道如何读取的二进制。

<img src='/images/assembly-to-machine-code-translation.png' loading='eager' style='max-width: 400px;' alt='一个演示机器码如何转换为汇编语言并返回的图表。一个双向箭头连接三个示例：机器码（二进制）后跟 3 个字节的二进制数，机器码（十六进制）后跟翻译成十六进制的 3 个字节（0x83、0xC3、0x0A），以及汇编后跟"add ebx, 10"。汇编和机器码使用颜色编码，因此很清楚机器码的每个字节都转换为汇编中的一个词。' width='935' height='505' />

> 补充说明：指令并不总是像上面的例子那样在机器码中以 1:1 的方式表示。例如，`add eax, 512` 转换为 `05 00 02 00 00`。
>
> 第一个字节（`05`）是一个操作码，专门表示*将 EAX 寄存器添加到 32 位数字*。剩余的字节是 512（`0x200`），采用[小端序](https://en.wikipedia.org/wiki/Endianness)字节顺序。
>
> Defuse Security 创建了一个[有用的工具](https://defuse.ca/online-x86-assembler.htm)，用于玩转汇编和机器码之间的转换。

RAM 是计算机的主存储器，一个大型多用途空间，存储计算机上运行的程序使用的所有数据。这包括程序代码本身以及操作系统核心的代码。CPU 总是直接从 RAM 读取机器码，如果代码没有加载到 RAM 中，就无法运行。

CPU 存储一个*指令指针*，它指向 RAM 中将要获取下一条指令的位置。执行每条指令后，CPU 移动指针并重复。这就是*取指-执行循环*。

<img src='/images/fetch-execute-cycle.png' loading='lazy' style='max-width: 360px; margin: 0 auto;' alt='一个演示取指-执行循环的图表。有两个文本气泡。第一个标记为"取指"，文本为"从当前指令指针处的内存中读取指令。"第二个标题为"执行"，文本为"运行指令，然后移动指令指针。"取指气泡有一个指向执行气泡的箭头，执行气泡有一个指向取指气泡的箭头，暗示一个重复的过程。' width='848' height='458' />

执行指令后，指针向前移动到 RAM 中指令之后的位置，以便它现在指向下一条指令。这就是代码运行的原因！指令指针只是不断向前推进，按照存储在内存中的顺序执行机器码。一些指令可以告诉指令指针跳转到其他地方，或者根据某个条件跳转到不同的地方；这使得可重用代码和条件逻辑成为可能。

这个指令指针存储在[*寄存器*](https://en.wikipedia.org/wiki/Processor_register)中。寄存器是小型存储桶，CPU 可以极快地读写。每个 CPU 架构都有一组固定的寄存器，用于从在计算期间存储临时值到配置处理器的所有事情。

一些寄存器可以直接从机器码访问，就像早期图表中的 `ebx` 一样。

其他寄存器仅由 CPU 内部使用，但通常可以使用专门的指令进行更新或读取。一个例子是指令指针，它不能直接读取，但可以使用例如跳转指令进行更新。

## 处理器是天真的

让我们回到最初的问题：当你在计算机上运行一个可执行程序时会发生什么？首先，发生一堆魔法来准备运行它——我们稍后会详细介绍所有这些——但在过程结束时，某个地方的文件中有机器码。操作系统将其加载到 RAM 中，并指示 CPU 将指令指针跳转到 RAM 中的该位置。CPU 像往常一样继续运行其取指-执行循环，因此程序开始执行！

（这对我来说是那些让我陷入困境的时刻之一——严肃地说，这就是你用来阅读这篇文章的程序的运行方式！你的 CPU 正在从 RAM 中按顺序获取浏览器的指令并直接执行它们，它们正在渲染这篇文章。）

<img src='/images/instruction-pointer.png' loading='lazy' style='max-width: 400px;' alt='一个描绘 RAM 中一系列机器码字节的图表。一个突出显示的字节由标记为"指令指针"的箭头指向，并且有箭头表示指令指针如何在 RAM 中向前移动。' width='935' height='372' />

事实证明，CPU 有一个超级基本的世界观；它们只看到当前的指令指针和一点内部状态。进程完全是操作系统的抽象，而不是 CPU 本地理解或跟踪的东西。

*\*挥手\* 进程是由 ~~操作系统开发人员~~ 大字节公司编造的抽象，用来销售更多计算机*

对我来说，这提出了比它回答的更多的问题：

1. 如果 CPU 不了解多进程处理，只是按顺序执行指令，为什么它不会卡在正在运行的任何程序中？多个程序如何同时运行？
2. 如果程序直接在 CPU 上运行，并且 CPU 可以直接访问 RAM，为什么代码不能访问其他进程的内存，或者，天哪，内核的内存？
3. 说到这，是什么机制阻止每个进程运行任何指令并对你的计算机做任何事情？系统调用到底是什么？

关于内存的问题值得单独讨论，并在[第 5 章](/the-translator-in-your-computer)中进行了介绍——简而言之，大多数内存访问实际上都经过一个重定向层，重新映射整个地址空间。现在，我们假设程序可以直接访问所有 RAM，并且计算机一次只能运行一个进程。我们将及时解释这两个假设。

是时候跳进我们的第一个兔子洞，进入一个充满系统调用和安全环的世界了。

> **补充说明：顺便说一句，什么是内核？**
>
> 你的计算机的操作系统，如 macOS、Windows 或 Linux，是在你的计算机上运行并使所有基本功能正常工作的软件集合。"基本功能"是一个非常笼统的术语，"操作系统"也是如此——根据你问的人，它可以包括默认情况下计算机附带的应用程序、字体和图标等内容。
>
> 然而，内核是操作系统的核心。当你启动计算机时，指令指针从某个地方的程序开始。该程序就是内核。内核几乎可以完全访问计算机的内存、外围设备和其他资源，并负责运行计算机上安装的软件（称为用户空间程序）。我们将在本文中学习内核如何拥有这种访问权限——以及用户空间程序如何没有。
>
> Linux 只是一个内核，需要大量用户空间软件（如 shell 和显示服务器）才能使用。macOS 中的内核称为 [XNU](https://en.wikipedia.org/wiki/XNU)，类似 Unix，现代 Windows 内核称为 [NT 内核](https://en.wikipedia.org/wiki/Architecture_of_Windows_NT)。

## 两个环来统治它们

处理器所处的*模式*（有时称为特权级别或环）控制它被允许做什么。现代架构至少有两个选项：内核/超级用户模式和用户模式。虽然一个架构可能支持两个以上的模式，但现在通常只使用内核模式和用户模式。

在内核模式下，一切皆有可能：CPU 被允许执行任何支持的指令并访问任何内存。在用户模式下，只允许一部分指令，I/O 和内存访问受到限制，许多 CPU 设置被锁定。通常，内核和驱动程序在内核模式下运行，而应用程序在用户模式下运行。

处理器以内核模式启动。在执行程序之前，内核启动切换到用户模式。

<img src='/images/kernel-mode-vs-user-mode.png' loading='lazy' style='max-width: 500px; margin: 0 auto;' alt='两个伪 iMessage 截图演示用户和内核模式保护之间的区别。第一个标记为内核模式：右侧说"读取这个受保护的内存！"，左侧回复"给你，亲爱的 :)"。第二个标记为用户模式：右侧说"读取这个受保护的内存！"，左侧回复"不！段错误！"' width='1072' height='433' />

处理器模式在真实架构中如何体现的一个例子：在 x86-64 上，可以从称为 `cs`（代码段）的寄存器中读取当前特权级别（CPL）。具体来说，CPL 包含在 `cs` 寄存器的两个[最低有效位](https://en.wikipedia.org/wiki/Bit_numbering)中。这两位可以存储 x86-64 的四个可能的环：环 0 是内核模式，环 3 是用户模式。环 1 和 2 设计用于运行驱动程序，但只有少数较旧的小众操作系统使用。例如，如果 CPL 位是 `11`，则 CPU 在环 3 中运行：用户模式。

## 系统调用到底是什么？

程序在用户模式下运行，因为它们不能被信任对计算机的完全访问。用户模式完成了它的工作，阻止对计算机大部分的访问——但程序需要能够访问 I/O、分配内存并以*某种方式*与操作系统交互！为此，在用户模式下运行的软件必须向操作系统内核寻求帮助。然后，操作系统可以实施自己的安全保护，以防止程序执行任何恶意操作。

如果你曾经编写过与操作系统交互的代码，你可能会认识诸如 `open`、`read`、`fork` 和 `exit` 之类的函数。在几个抽象层之下，这些函数都使用*系统调用*来向操作系统寻求帮助。系统调用是一种特殊的过程，让程序开始从用户空间到内核空间的转换，从程序的代码跳转到操作系统代码。

用户空间到内核空间的控制转移是使用称为[*软件中断*](https://en.wikipedia.org/wiki/Interrupt#Software_interrupts)的处理器功能完成的：

1. 在引导过程中，操作系统将一个称为[*中断向量表*](https://en.wikipedia.org/wiki/Interrupt_vector_table)（IVT；x86-64 将其称为[中断描述符表](https://en.wikipedia.org/wiki/Interrupt_descriptor_table)）的表存储在 RAM 中，并向 CPU 注册它。IVT 将中断编号映射到处理程序代码指针。

  <img src='/images/interrupt-vector-table.png' loading='lazy' style='max-width: 300px; margin: 0 auto;' alt='一个标题为"中断向量表"的表的图像。第一列标记为数字符号，有一系列数字从 01 开始到 04。相应的第二列标记为"处理程序地址"，每个条目包含一个随机的 8 字节长的十六进制数。表的底部有文本"依此类推……"' width='555' height='463' />

2. 然后，用户空间程序可以使用像 [INT](https://www.felixcloutier.com/x86/intn:into:int3:int1) 这样的指令，它告诉处理器在 IVT 中查找给定的中断编号，切换到内核模式，然后将指令指针跳转到存储在 IVT 中的内存地址。

当这个内核代码完成时，它使用像 [IRET](https://www.felixcloutier.com/x86/iret:iretd:iretq) 这样的指令告诉 CPU 切换回用户模式，并将指令指针返回到触发中断时的位置。

（如果你好奇的话，Linux 上用于系统调用的中断 ID 是 `0x80`。你可以在 [Michael Kerrisk 的在线手册页目录](https://man7.org/linux/man-pages/man2/syscalls.2.html)上阅读 Linux 系统调用列表。）

### 包装器 API：抽象化中断

以下是我们到目前为止对系统调用的了解：

- 用户模式程序不能直接访问 I/O 或内存。它们必须向操作系统寻求帮助与外部世界交互。
- 程序可以使用像 INT 和 IRET 这样的特殊机器码指令将控制委托给操作系统。
- 程序不能直接切换特权级别；软件中断是安全的，因为处理器已经*由操作系统*预先配置了跳转到操作系统代码中的位置。中断向量表只能从内核模式配置。

程序在触发系统调用时需要将数据传递给操作系统；操作系统需要知道要执行哪个特定的系统调用以及系统调用本身需要的任何数据，例如，要打开的文件名。传递此数据的机制因操作系统和架构而异，但通常是通过在触发中断之前将数据放入某些寄存器或堆栈中来完成的。

跨设备调用系统调用的方式的差异意味着程序员为每个程序自己实现系统调用将是极不切实际的。这也意味着操作系统不能改变其中断处理，因为担心破坏使用旧系统编写的每个程序。最后，我们通常不再用原始汇编编写程序——不能指望程序员在想要读取文件或分配内存时就降级到汇编。

<img src='/images/syscall-architecture-differences.png' loading='lazy' style='max-width: 650px; margin: 0 auto;' alt='一幅标题为"系统调用在不同架构中的实现不同"的图画。左边是一个微笑的 CPU 接收一些二进制并输出文件名 file.txt。右边分开的是另一个 CPU 接收相同的二进制数据，但表情困惑和恶心。' width='1057' height='360' />

因此，操作系统在这些中断之上提供了一个抽象层。在类 Unix 系统上由 [libc](https://www.gnu.org/software/libc/) 提供的可重用高级库函数包装必要的汇编指令，在 Windows 上由一个名为 [ntdll.dll](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/libraries-and-headers) 的库的一部分提供。调用这些库函数本身不会导致切换到内核模式，它们只是标准函数调用。在库内部，汇编代码确实将控制转移到内核，并且比包装库子例程更依赖于平台。

当你从在类 Unix 系统上运行的 C 调用 `exit(1)` 时，该函数在内部运行机器码来触发中断，在将系统调用的操作码和参数放入正确的寄存器/堆栈/任何东西之后。计算机太酷了！

## 速度的需求 / 让我们变得 CISC-y

许多 [CISC](https://en.wikipedia.org/wiki/Complex_instruction_set_computer) 架构（如 x86-64）包含专为系统调用设计的指令，这是由于系统调用范式的流行而创建的。

Intel 和 AMD 在 x86-64 上的协调做得不太好；它实际上有*两组*优化的系统调用指令。[SYSCALL](https://www.felixcloutier.com/x86/syscall.html) 和 [SYSENTER](https://www.felixcloutier.com/x86/sysenter) 是像 `INT 0x80` 这样的指令的优化替代方案。它们相应的返回指令 [SYSRET](https://www.felixcloutier.com/x86/sysret.html) 和 [SYSEXIT](https://www.felixcloutier.com/x86/sysexit) 设计用于快速转换回用户空间并恢复程序代码。

（AMD 和 Intel 处理器对这些指令的兼容性略有不同。`SYSCALL` 通常是 64 位程序的最佳选择，而 `SYSENTER` 对 32 位程序有更好的支持。）

代表该风格的 [RISC](https://en.wikipedia.org/wiki/Reduced_instruction_set_computer) 架构往往没有这样的特殊指令。AArch64，Apple Silicon 基于的 RISC 架构，对系统调用和软件中断使用[一个中断指令](https://developer.arm.com/documentation/ddi0596/2021-12/Base-Instructions/SVC--Supervisor-Call-)。我认为 Mac 用户做得很好&nbsp;:)

---

呼，内容很多！让我们简要回顾一下：

- 处理器在无限的取指-执行循环中执行指令，并且没有操作系统或程序的概念。处理器的模式，通常存储在寄存器中，决定可以执行哪些指令。操作系统代码在内核模式下运行，并切换到用户模式来运行程序。
- 要运行二进制文件，操作系统切换到用户模式并将处理器指向 RAM 中代码的入口点。因为它们只有用户模式的特权，想要与世界交互的程序需要跳转到操作系统代码以寻求帮助。系统调用是程序从用户模式切换到内核模式并进入操作系统代码的标准化方式。
- 程序通常通过调用共享库函数来使用这些系统调用。这些包装软件中断或架构特定的系统调用指令的机器码，将控制转移到操作系统内核并切换环。内核完成其业务并切换回用户模式并返回到程序代码。

让我们弄清楚如何回答我之前的第一个问题：

> 如果 CPU 不跟踪多个进程，只是一条接一条地执行指令，为什么它不会卡在正在运行的任何程序中？多个程序如何同时运行？

我亲爱的朋友，这个问题的答案也是为什么 Coldplay 如此受欢迎的答案……时钟！（好吧，严格来说是计时器。我只是想硬塞这个笑话。）
