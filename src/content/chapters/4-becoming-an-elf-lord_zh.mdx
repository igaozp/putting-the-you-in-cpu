---
chapter: 4
title: 成为 ELF 领主
shortname: ELF
slug: becoming-an-elf-lord
updatedAt: 2023-07-17T17:16:18.079Z
---

import CodeBlock from '../../components/CodeBlock.astro'

我们现在非常彻底地理解了 `execve`。在大多数路径的末尾，内核将到达一个包含要启动的机器码的最终程序。通常，在实际跳转到代码之前需要一个设置过程——例如，程序的不同部分必须加载到内存中的正确位置。每个程序需要不同数量的内存用于不同的事情，所以我们有标准文件格式来指定如何设置程序以执行。虽然 Linux 支持许多这样的格式，但迄今为止最常见的格式是 *ELF*（可执行和可链接格式）。

<p>
	<img src='/images/gnu-linux-elf-drawing.jpg' loading='eager' style='max-width: 260px; margin: 0 auto;' alt='纸上的马克笔画。一个巫师精灵正在冥想，一只手握着一只 gnu 的头，另一只手握着一只 Linux 企鹅。精灵说"好吧，实际上，Linux 只是内核，操作系统是……"这幅画用红色马克笔标注："你听说过架子上的精灵！现在，准备好……GNU/Linux 上的精灵。"这幅画签名为"Nicky"。' width='529' height='256' />
</p>
<div style='text-align: center;'>
	<p style='margin-top: -10px;'>
		（感谢 <a href='https://ncase.me/' target='_blank'>Nicky Case</a> 提供的可爱图画。）
	</p>
</div>

> **补充说明：精灵无处不在吗？**
>
> 当你在 Linux 上运行应用程序或命令行程序时，它极有可能是 ELF 二进制文件。然而，在 macOS 上，事实上的格式是 [Mach-O](https://en.wikipedia.org/wiki/Mach-O)。Mach-O 做所有与 ELF 相同的事情，但结构不同。在 Windows 上，.exe 文件使用[可移植可执行文件](https://en.wikipedia.org/wiki/Portable_Executable)格式，这又是一种具有相同概念的不同格式。

在 Linux 内核中，ELF 二进制文件由 `binfmt_elf` 处理程序处理，它比许多其他处理程序更复杂，包含数千行代码。它负责从 ELF 文件中解析出某些细节，并使用它们将进程加载到内存中并执行它。

*我运行了一些命令行功夫来按行数对 binfmt 处理程序进行排序：*

<CodeBlock name='Shell session'>
```
$ wc -l binfmt_* | sort -nr | sed 1d
    2181 binfmt_elf.c
    1658 binfmt_elf_fdpic.c
     944 binfmt_flat.c
     836 binfmt_misc.c
     158 binfmt_script.c
      64 binfmt_elf_test.c
```
</CodeBlock>

## 文件结构

在更深入地查看 `binfmt_elf` 如何执行 ELF 文件之前，让我们看一下文件格式本身。ELF 文件通常由四个部分组成：

<img src='/images/elf-file-structure.png' loading='lazy' style='max-width: 500px; margin: 0 auto;' alt='一个显示 ELF 文件结构概述的图表，有四个顺序部分。第 1 部分，ELF 头：关于二进制文件的基本信息，以及 PHT 和 SHT 的位置。第 2 部分，程序头表（PHT）：描述如何以及在何处将 ELF 文件的数据加载到内存中。第 3 部分，节头表（SHT）：可选的数据"地图"以协助调试。第 4 部分，数据：二进制文件的所有数据。PHT 和 SHT 指向此部分。' width='1033' height='786' />

### ELF 头

每个 ELF 文件都有一个 [ELF 头](https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html)。它有传达关于二进制文件的基本信息的非常重要的工作，例如：

- 它设计用于在哪个处理器上运行。ELF 文件可以包含不同处理器类型的机器码，如 ARM 和 x86。
- 二进制文件是打算单独作为可执行文件运行，还是打算作为"动态链接库"由其他程序加载。我们很快就会详细介绍什么是动态链接。
- 可执行文件的入口点。后面的部分精确指定将 ELF 文件中包含的数据加载到内存中的哪个位置。入口点是一个内存地址，指向整个进程加载后第一条机器码指令在内存中的位置。

ELF 头总是在文件的开头。它指定程序头表和节头的位置，它们可以在文件中的任何位置。这些表反过来指向存储在文件中其他位置的数据。

### 程序头表

[程序头表](https://refspecs.linuxbase.org/elf/gabi4+/ch5.pheader.html)是一系列条目，包含有关如何在运行时加载和执行二进制文件的具体细节。每个条目都有一个类型字段，说明它指定的是什么细节——例如，`PT_LOAD` 表示它包含应该加载到内存中的数据，但 `PT_NOTE` 表示段包含不一定应该加载到任何地方的信息文本。

<img src='/images/elf-program-header-types.png' loading='lazy' style='max-width: 500px; margin: 0 auto;' alt='一个显示四种不同常见程序头类型的表。类型 1，PT_LOAD：要加载到内存中的数据。类型 2，PT_NOTE：自由形式文本，如版权声明、版本信息等。类型 3，PT_DYNAMIC：关于动态链接的信息。类型 4，PT_INTERP："ELF 解释器"位置的路径。' width='904' height='338' />

每个条目都指定关于其数据在文件中的位置以及有时如何将数据加载到内存中的信息：

- 它指向其数据在 ELF 文件中的位置。
- 它可以指定数据应该加载到内存中的哪个虚拟内存地址。如果段不打算加载到内存中，这通常留空。
- 两个字段指定数据的长度：一个是文件中数据的长度，一个是要创建的内存区域的长度。如果内存区域长度长于文件中的长度，额外的内存将用零填充。这对于可能希望在运行时使用静态内存段的程序是有益的；这些空内存段通常称为 [BSS](https://en.wikipedia.org/wiki/.bss) 段。
- 最后，一个标志字段指定如果它被加载到内存中应该允许哪些操作：`PF_R` 使其可读，`PF_W` 使其可写，`PF_X` 表示它是应该被允许在 CPU 上执行的代码。

### 节头表

[节头表](https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html)是一系列包含关于*节*的信息的条目。这个节信息就像一张地图，绘制 ELF 文件内部的数据。它使[像调试器这样的程序](https://www.sourceware.org/gdb/)容易理解数据不同部分的预期用途。

<img src='/images/elf-section-header-table-diagram.png' loading='lazy' style='max-width: 450px; margin: 0 auto;' alt='一张带有岛屿、河流、棕榈树和罗盘玫瑰的旧藏宝图。一些岛屿标有 ELF 节名称，如".text"、".data"、".shstrtab"和".bss"。这幅画标题为"节头表就像二进制数据的地图"。' width='701' height='617' />

例如，程序头表可以指定一大块数据一起加载到内存中。单个 `PT_LOAD` 块可能同时包含代码和全局变量！没有理由必须单独指定这些来*运行*程序；CPU 只是从入口点开始并向前步进，在程序请求时访问数据。然而，像调试器这样用于*分析*程序的软件需要准确知道每个区域的开始和结束位置，否则它可能会尝试将一些说"hello"的文本解码为代码（由于这不是有效代码，会爆炸）。这些信息存储在节头表中。

虽然通常包含，但节头表实际上是可选的。ELF 文件可以在完全删除节头表的情况下完美运行，想要隐藏其代码的开发人员有时会故意剥离或破坏其 ELF 二进制文件的节头表，以[使它们更难解码](https://binaryresearch.github.io/2019/09/17/Analyzing-ELF-Binaries-with-Malformed-Headers-Part-1-Emulating-Tiny-Programs.html)。

每个节都有一个名称、一个类型和一些标志，这些标志指定它打算如何使用和解码。标准名称通常按照惯例以点开头。最常见的节是：

- `.text`：要加载到内存中并在 CPU 上执行的机器码。`SHT_PROGBITS` 类型带有 `SHF_EXECINSTR` 标志以将其标记为可执行，以及 `SHF_ALLOC` 标志，这意味着它被加载到内存中以执行。（不要被名称混淆，它仍然只是二进制机器码！我一直发现它被称为 `.text` 有点奇怪，尽管它不是可读的"文本"。）
- `.data`：在可执行文件中硬编码以加载到内存中的初始化数据。例如，包含一些文本的全局变量可能在此节中。如果你编写低级代码，这是静态变量所在的节。它也有类型 `SHT_PROGBITS`，这只是意味着节包含"程序的信息"。它的标志是 `SHF_ALLOC` 和 `SHF_WRITE`，将其标记为可写内存。
- `.bss`：我之前提到过，拥有一些以零开头的分配内存是很常见的。在 ELF 文件中包含一堆空字节将是一种浪费，因此使用了一种称为 BSS 的特殊段类型。在调试期间了解 BSS 段很有帮助，因此还有一个节头表条目指定要分配的内存的长度。它是 `SHT_NOBITS` 类型，并标记为 `SHF_ALLOC` 和 `SHF_WRITE`。
- `.rodata`：这类似于 `.data`，只是它是只读的。在一个非常基本的 C 程序中运行 `printf("Hello, world!")`，字符串"Hello world!"将在 `.rodata` 节中，而实际的打印代码将在 `.text` 节中。
- `.shstrtab`：这是一个有趣的实现细节！节本身的名称（如 `.text` 和 `.shstrtab`）不直接包含在节头表中。相反，每个条目都包含到 ELF 文件中包含其名称的位置的偏移量。这样，节头表中的每个条目可以是相同的大小，使它们更容易解析——到名称的偏移量是一个固定大小的数字，而在表中包含名称将使用可变大小的字符串。所有这些名称数据都存储在称为 `.shstrtab` 的自己的节中，类型为 `SHT_STRTAB`。

### 数据

程序和节头表条目都指向 ELF 文件中的数据块，无论是将它们加载到内存中，指定程序代码在哪里，还是只是命名节。所有这些不同的数据片段都包含在 ELF 文件的数据部分中。

<img src='/images/elf-data-section.png' loading='lazy' style='max-width: 680px;' alt='一个演示 ELF 文件的不同部分如何引用数据块内位置的图表。描绘了一个连续的数据集合，最后淡出，包含一些清晰可识别的东西，如 ELF 解释器的路径、节标题".rodata"和字符串"Hello, world!"几个示例 ELF 节漂浮在数据块上方，箭头指向它们的数据。例如，PHT 和 SHT 条目示例中的数据部分都指向相同的"Hello, world!"文本。SHT 条目的标签也存储在数据块中。' width='1210' height='386' />

## 链接的简要说明

回到 `binfmt_elf` 代码：内核关心程序头表中的两种类型的条目。

`PT_LOAD` 段指定所有程序数据（如 `.text` 和 `.data` 节）需要加载到内存中的位置。内核从 ELF 文件中读取这些条目以将数据加载到内存中，以便 CPU 可以执行程序。

内核关心的另一种程序头表条目类型是 `PT_INTERP`，它指定一个"动态链接运行时"。

在我们讨论什么是动态链接之前，让我们先讨论一般的"链接"。程序员倾向于在可重用代码库的基础上构建他们的程序——例如，我们之前讨论过的 libc。当将你的源代码转换为可执行二进制文件时，一个称为链接器的程序通过查找库代码并将其复制到二进制文件中来解析所有这些引用。这个过程称为*静态链接*，这意味着外部代码直接包含在分发的文件中。

然而，一些库非常常见。你会发现 libc 基本上被阳光下的每个程序使用，因为它是通过系统调用与操作系统交互的规范接口。在你的计算机上的每个程序中包含一个单独的 libc 副本将是对空间的可怕使用。此外，如果库中的错误可以在一个地方修复，而不是必须等待使用该库的每个程序更新，那就太好了。动态链接是这些问题的解决方案。

如果一个静态链接的程序需要一个名为 `bar` 的库中的函数 `foo`，程序将包含 `foo` 的整个副本。然而，如果它是动态链接的，它只会包含一个说"我需要库 `bar` 中的 `foo`"的引用。当程序运行时，`bar` 希望安装在计算机上，`foo` 函数的机器码可以按需加载到内存中。如果计算机上 `bar` 库的安装被更新，新代码将在程序下次运行时加载，而无需对程序本身进行任何更改。

<img src='/images/static-vs-dynamic-linking.png' loading='lazy' alt='一个显示静态链接和动态链接之间区别的图表。在左侧，静态链接显示一些名为"foo"的代码的内容被分别复制到两个程序中。这伴随着文本说，库函数在构建时从开发人员的计算机复制到每个二进制文件中。在右侧，显示动态链接：每个程序都包含"foo"函数的名称，箭头指向程序外部，指向用户计算机上的 foo 程序。这与说明二进制文件引用库函数的名称的附带文本配对，这些函数在运行时从用户的计算机加载。' width='1800' height='860' class='big' style='--max-width: 900px;' />

## 野外的动态链接

在 Linux 上，像 `bar` 这样的动态可链接库通常打包到具有 .so（共享对象）扩展名的文件中。这些 .so 文件就像程序一样是 ELF 文件——你可能还记得 ELF 头包含一个字段来指定文件是可执行文件还是库。此外，共享对象在节头表中有一个 `.dynsym` 节，其中包含关于从文件导出的符号以及可以动态链接到的符号的信息。

在 Windows 上，像 `bar` 这样的库被打包到 .dll（**d**ynamic **l**ink **l**ibrary）文件中。macOS 使用 .dylib（**dy**namically linked **lib**rary）扩展名。就像 macOS 应用程序和 Windows .exe 文件一样，这些格式与 ELF 文件略有不同，但概念和技术相同。

两种链接类型之间的一个有趣区别是，使用静态链接，只有使用的库部分包含在可执行文件中，因此加载到内存中。使用动态链接，*整个库*被加载到内存中。这最初可能听起来效率较低，但它实际上允许现代操作系统通过将库加载到内存中一次然后在进程之间共享该代码来节省*更多*空间。只有代码可以共享，因为库需要不同程序的不同状态，但节省仍然可以达到数十到数百兆字节的 RAM。

## 执行

让我们回到运行 ELF 文件的内核：如果它正在执行的二进制文件是动态链接的，操作系统不能立即跳转到二进制文件的代码，因为会缺少代码——记住，动态链接的程序只有对它们需要的库函数的引用！

要运行二进制文件，操作系统需要弄清楚需要哪些库，加载它们，用实际的跳转指令替换所有命名指针，*然后*启动实际的程序代码。这是与 ELF 格式深度交互的非常复杂的代码，因此它通常是一个独立的程序，而不是内核的一部分。ELF 文件在程序头表中的 `PT_INTERP` 条目中指定它们想要使用的程序的路径（通常类似于 `/lib64/ld-linux-x86-64.so.2`）。

在读取 ELF 头并扫描程序头表之后，内核可以为新程序设置内存结构。它首先将所有 `PT_LOAD` 段加载到内存中，填充程序的静态数据、BSS 空间和机器码。如果程序是动态链接的，内核将不得不执行 [ELF 解释器](https://unix.stackexchange.com/questions/400621/what-is-lib64-ld-linux-x86-64-so-2-and-why-can-it-be-used-to-execute-file)（`PT_INTERP`），所以它还将解释器的数据、BSS 和代码加载到内存中。

现在内核需要为 CPU 设置指令指针，以便在返回用户空间时恢复。如果可执行文件是动态链接的，内核将指令指针设置为内存中 ELF 解释器代码的开头。否则，内核将其设置为可执行文件的开头。

内核几乎准备好从系统调用返回（记住，我们仍然在 `execve` 中）。它将 `argc`、`argv` 和环境变量推送到堆栈中，以便程序在开始时读取。

寄存器现在被清除。在处理系统调用之前，内核将寄存器的当前值存储到堆栈中，以便在切换回用户空间时恢复。在返回用户空间之前，内核将堆栈的这一部分清零。

最后，系统调用结束，内核返回用户空间。它恢复寄存器，现在是清零的，并跳转到存储的指令指针。该指令指针现在是新程序（或 ELF 解释器）的起点，当前进程已被替换！
